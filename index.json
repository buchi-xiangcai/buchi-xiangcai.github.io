[{"categories":["其他"],"content":"nvm 切换不同版本的 node 最近项目中出现了一个问题，就是 node-sass 这个包一直安装失败。后来发现电脑中的 node.js 的版本太高导致。node-sass 是不支持 node16 以上的版本的。 可以通过 nvm 在电脑上切换不同版本的 node.js 安装方式： ","date":"2023-03-06","objectID":"/mac%E5%AE%89%E8%A3%85nvm/:0:0","tags":["node"],"title":"mac安装nvm切换Node版本","uri":"/mac%E5%AE%89%E8%A3%85nvm/"},{"categories":["其他"],"content":"1.在 vscode 中打开终端，下载安装包：（最好使用流量下载） sudo curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.38.0/install.sh | bash ","date":"2023-03-06","objectID":"/mac%E5%AE%89%E8%A3%85nvm/:0:1","tags":["node"],"title":"mac安装nvm切换Node版本","uri":"/mac%E5%AE%89%E8%A3%85nvm/"},{"categories":["其他"],"content":"2. 刷新使其全局生效： 正常安装好之后，nvm 会自动在 mac 电脑的全局配置文件中，配置好相应的环境变量 位置为：~/.bash_profile 内容为： export NVM_DIR=\"$HOME/.nvm\" [ -s \"$NVM_DIR/nvm.sh\" ] \u0026\u0026 \\. \"$NVM_DIR/nvm.sh\" # This loads nvm [ -s \"$NVM_DIR/bash_completion\" ] \u0026\u0026 \\. \"$NVM_DIR/bash_completion\" # This loads nvm bash_completion 上面的内容无需操作，但是此时环境变量并没有生效，我们需要刷新环境变量：执行如下命令 source ~/.bash_profile ","date":"2023-03-06","objectID":"/mac%E5%AE%89%E8%A3%85nvm/:0:2","tags":["node"],"title":"mac安装nvm切换Node版本","uri":"/mac%E5%AE%89%E8%A3%85nvm/"},{"categories":["其他"],"content":"3.验证生效 nvm -v 此时如果正确打印出版本号，代表已经安装成功。 ","date":"2023-03-06","objectID":"/mac%E5%AE%89%E8%A3%85nvm/:0:3","tags":["node"],"title":"mac安装nvm切换Node版本","uri":"/mac%E5%AE%89%E8%A3%85nvm/"},{"categories":["其他"],"content":"4.常用命令 nvm 常用命令 nvm install stable ## 安装最新稳定版 node，当前是 node v9.5.0 (npm v5.6.0) nvm install ## 安装指定版本，可模糊安装，如：安装 v4.4.0，既可 nvm install v4.4.0，又可 nvm install 4.4 nvm uninstall ## 删除已安装的指定版本，语法与 install 类似 nvm use ## 切换使用指定的版本 node nvm ls ## 列出所有安装的版本 nvm ls-remote ## 列出所有远程服务器的版本（官方 node version list） nvm current ## 显示当前的版本 nvm alias ## 给不同的版本号添加别名 nvm unalias ## 删除已定义的别名 nvm reinstall-packages ## 在当前版本 node 环境下，重新全局安装指定版本号的 npm 包 ","date":"2023-03-06","objectID":"/mac%E5%AE%89%E8%A3%85nvm/:0:4","tags":["node"],"title":"mac安装nvm切换Node版本","uri":"/mac%E5%AE%89%E8%A3%85nvm/"},{"categories":["其他"],"content":"5. 举例： 我需要使用 node14 版本： nvm install 14 #等待安装结束 nvm use 14 ","date":"2023-03-06","objectID":"/mac%E5%AE%89%E8%A3%85nvm/:0:5","tags":["node"],"title":"mac安装nvm切换Node版本","uri":"/mac%E5%AE%89%E8%A3%85nvm/"},{"categories":["其他"],"content":"6.注意事项 如果使用过程中，又出现 nvm command not found，重新执行如下命令： source ~/.bash_profile ","date":"2023-03-06","objectID":"/mac%E5%AE%89%E8%A3%85nvm/:0:6","tags":["node"],"title":"mac安装nvm切换Node版本","uri":"/mac%E5%AE%89%E8%A3%85nvm/"},{"categories":["vue"],"content":"push() pop() shift() splice() sort() reverse() filter() push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。 new Vue({ data:{ arr: ['苹果','香蕉','橙子'] }, methods:{ addData(){ this.arr.push(\"石榴\"); } } }) console.log(arr) 苹果，香蕉，橙子，石榴 pop() 方法用于删除最后一位元素并返回数组的最后一个元素。 new Vue({ data:{ arr: ['苹果','香蕉','橙子'] }, methods:{ moveData(){ this.arr.pop(); } } }) console.log(arr) 苹果，香蕉 shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。 new Vue({ data:{ arr: ['苹果','香蕉','橙子'] }, methods:{ moveData(){ this.arr.shift(); } } }) console.log(arr) 香蕉，橙子 unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度. new Vue({ data:{ arr: ['苹果','香蕉','橙子'] }, methods:{ addData(){ this.arr.unshift(\"石榴\",\"枇杷\"); } } }) 石榴,枇杷,苹果，香蕉，橙子 splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。 splice(　index,　len,　[item]) 用来删除/替换/添加数组内某一个或者几个值（该方法会改变原始数组）。 参数：index：数组开始下标 len：替换/删除的长度 item：替换的值，删除操作的话item为空 删除： //删除起始下标为1，长度为1的一个值（len设置1，如果为0，则数组不变） 例:splice(1);保留前一个元素之后的全部删除，splice(2);保留前两个元素之后的全部删除 let arr = ['a', 'b', 'c', 'd'] arr.splice(2) console.log(arr) //[\"a\", \"b\"] 例:splice(2, 1) 从索引位置(index:2)删除，删除一个元素 let arr = ['a', 'b', 'c', 'd'] arr.splice(2, 1) console.log(arr) // [\"a\", \"b\", \"d\"] 例:splice(1,2,‘a’,‘b’) 从索引位置(index:1)删除，删除2个元素，并添加2个新元素来替代被删除的元素 let arr = ['a', 'b', 'c', 'd'] arr.splice(1, 2, '1', '2') console.log(arr) // [\"a\", \"1\", \"2\", \"d\"] 删除 new Vue({ data:{ arr: ['a','b','c','d'] }, methods:{ moveData(){ this.arr.splice(1,1); } } }) 【‘a’,‘c’,‘d’】 替换 new Vue({ data:{ arr: ['a','b','c','d'] }, methods:{ replaceData(){ this.arr.splice(1,1,'ttt'); } } }) [‘a’,‘ttt’,‘c’,‘d’] 添加 new Vue({ data:{ arr: ['a','b','c','d'] }, methods:{ addData(){ this.arr.splice(1,0,'ttt'); } } }) [‘a’,‘ttt’,‘b’,‘c’,‘d’] 例:splice(1,0,‘a’)从索引位置(index:1)添加，添加两个元素 let arr = ['a', 'b', 'c', 'd'] arr.splice(1, 0, '1', '2') console.log(arr) // [\"a\", \"1\", \"2\", \"b\", \"c\", \"d\"] sort() 方法用于对数组的元素进行排序。 new Vue({ data:{ arr: [ {\"id\":0,\"title\":\"11111\",\"cont\":\"99999\"}, {\"id\":1,\"title\":\"22222\",\"cont\":\"22222\"}, {\"id\":2,\"title\":\"33333\",\"cont\":\"33333\"}, ] }, methods:{ sortData(){ this.list.sort((a,b)=\u003ea.cont-b.cont); } } }) 大小排序 function sortNumber (a, b) { return a - b } let arr = [10,5,40,25,1000,1] arr.sort(sortNumber) console.log(arr) // [1, 5, 10, 25, 40, 1000] reverse() 方法用于颠倒数组中元素的顺序。 new Vue({ data:{ arr: [ {\"id\":0,\"title\":\"11111\",\"cont\":\"99999\"}, {\"id\":1,\"title\":\"22222\",\"cont\":\"22222\"}, {\"id\":2,\"title\":\"33333\",\"cont\":\"33333\"}, {\"id\":3,\"title\":\"44444\",\"cont\":\"44444\"}, {\"id\":4,\"title\":\"55555\",\"cont\":\"55555\"}, {\"id\":5,\"title\":\"66666\",\"cont\":\"66666\"}, {\"id\":6,\"title\":\"77777\",\"cont\":\"77777\"}, {\"id\":7,\"title\":\"77777\",\"cont\":\"88888\"} ] }, methods:{ reverserData(){ this.list.reverse(); } } }) 替换数组 filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。 \u003cel-input placeholder=\"输入关键字进行过滤\" v-model=\"filterText\"\u003e \u003cel-tree :data=\"treeData\" :props=\"defaultProps\" default-expand-all ref=\"tree\" @node-click=\"handleNodeClick\" :filter-node-method=\"filterNode\" class=\"text_2\" \u003e \u003c/el-tree\u003e filterText: \"\", watch: { filterText(val) { this.$refs.tree.filter(val); }, }, concat() 方法用于连接两个或多个数组。 split() 方法用于把一个字符串分割成字符串数组。 \u003cdiv\u003e{{ tips }} 反转的结果是：{{ tips.split('').reverse().join('') }}\u003c/div\u003e data: { tips: '请输入用户名', } //名户用入输请 v-html v-text \u003cbody\u003e \u003cdiv id=\"div\"\u003e \u003c!--示例：使用3种方式设置span标签体的内容--\u003e \u003cdiv\u003e方式1：\u003cspan\u003e{{msg}}\u003c/span\u003e\u003c/div\u003e \u003cdiv\u003e方式2：\u003cspan v-text=\"msg\"\u003e\u003c/span\u003e\u003c/div\u003e \u003cdiv\u003e方式3：\u003cspan v-html=\"msg\"\u003e\u003c/span\u003e\u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003cscript src=\"js/vue.js\"\u003e\u003c/script\u003e \u003cscript\u003e //目标：给视图标签体绑定数据 //方式1：{{变量名}} 插入值表达式，标签体绑定文本字符串，类似于innerText的功能 //方式2：v-text=\"变量名\"，与{{变量名}}功能一样 //方式3：v-html=\"变量名\"，标签体绑定html代码字符串，类似于innerHTML的功能 // v-html 或 v-text 都是设置在视图标签的属性位置 new Vue({ el:\"#div\", data:{ msg:\"\u003ch1\u003eHello Vue\u003c/h1\u003e\" } }); \u003c/script\u003e \u003cbody\u003e \u003c!-- 希望 Vue 能够控制下面的这个 div，帮我们在把数据填充到 div 内部 --\u003e \u003cdiv id=\"app\"\u003e \u003cp v-text=\"username\"\u003e\u003c/p\u003e \u003cp v-text=\"gender\"\u003e性别：\u003c/p\u003e \u003chr\u003e \u003cp\u003e姓名：{{ username }}\u003c/p\u003e \u003cp\u003e性别：{{ gender }}\u003c/p\u003e \u003chr\u003e \u003cdiv v-text=\"info\"\u003e\u003c/div\u003e \u003cdiv\u003e{{ info }}\u003c/div\u003e \u003cdiv v-html=\"info\"\u003e\u003c/div\u003e \u003c/div\u003e \u003c!-- 1. 导入 Vue 的库文件，在 window 全局就有了 Vue 这个构造函数 --\u003e \u003cscript src=\"./lib/vue-2.6.12.js\"\u003e\u003c/script\u003e \u003c!-- 2. 创建 Vue 的实例对象 --\u003e \u003cscript\u003e // 创建 ","date":"2023-03-06","objectID":"/vue%E7%AC%94%E8%AE%B0/:0:0","tags":["vue"],"title":"vue基础","uri":"/vue%E7%AC%94%E8%AE%B0/"},{"categories":["vue"],"content":"1. 父-\u003e子 方式：通过子组件props属性来传递数据 props是一个数组 注意：属性的值必须在组件中通过props属性显示指定，否则，不会生效 说明：传递过来的props属性的用法与data属性的用法相同 \u003cdiv id=\"app\"\u003e \u003c!-- 如果需要往子组件总传递父组件data中的数据 需要加v-bind=\"数据名称\" --\u003e \u003chello v-bind:msg=\"info\"\u003e\u003c/hello\u003e \u003c!-- 如果传递的是字面量 那么直接写--\u003e \u003chello my-msg=\"abc\"\u003e\u003c/hello\u003e \u003c/div\u003e \u003c!-- js --\u003e \u003cscript\u003escript\"\u003e new Vue({ el: \"#app\", data : { info : 15 }, components: { hello: { // 创建props及其传递过来的属性 props: ['msg', 'myMsg'], template: '\u003ch1\u003e这是 hello 组件，这是消息：template-variable\"\u003e{{msg}} --- template-variable\"\u003e{{myMsg}}\u003c/h1\u003e' } } }) \u003c/script\u003e ","date":"2023-03-06","objectID":"/vue%E7%AC%94%E8%AE%B0/:1:0","tags":["vue"],"title":"vue基础","uri":"/vue%E7%AC%94%E8%AE%B0/"},{"categories":["vue"],"content":"2. 子-\u003e父 方式：父组件给子组件传递一个函数，由子组件调用这个函数 说明：借助vue中的自定义事件（v-on:cunstomFn=“fn”） 步骤: 1、在父组件中定义方法 parentFn 2、在子组件 组件引入标签 中绑定自定义事件 v-on:自定义事件名=“父组件中的方法” ==\u003e @pfn=“parentFn” 3、子组件中通过$emit()触发自定义事件事件 this.$emit(pfn,参数列表。。。) \u003chello @pfn=\"parentFn\"\u003e\u003c/hello\u003e \u003cscript\u003escript\"\u003e Vue.component('hello', { template: '\u003cbutton @click=\"fn\"\u003e按钮\u003c/button\u003e', methods: { // 子组件：通过$emit调用 fn() { this.$emit('pfn', '这是子组件传递给父组件的数据') } } }) new Vue({ methods: { // 父组件：提供方法 parentFn(data) { console.log('父组件：', data) } } }) \u003c/script\u003e ","date":"2023-03-06","objectID":"/vue%E7%AC%94%E8%AE%B0/:2:0","tags":["vue"],"title":"vue基础","uri":"/vue%E7%AC%94%E8%AE%B0/"},{"categories":["vue"],"content":"3.非父子组件 $on()：绑定自定义事件 var bus = new Vue() // 在组件 B 绑定自定义事件 bus.$on('id-selected', function\"\u003efunction (id) { // ... }) // 触发组件 A 中的事件 bus.$emit('id-selected', 1) 示例：组件A —\u003e 组件B \u003c!-- 组件A： --\u003e \u003ccom-a\u003e\u003c/com-a\u003e \u003c!-- 组件B： --\u003e \u003ccom-b\u003e\u003c/com-b\u003e \u003cscript\u003escript\"\u003e // 中间组件 var bus = new Vue() // 通信组件 var vm = new Vue({ el: '#app', components: { comB: { template: '\u003cp\u003e组件A告诉我：{{msg}}\u003c/p\u003e', data() { return { msg: '' } }, created() { // 给中间组件绑定自定义事件 注意:如果用到this 需要用箭头函数 bus.$on('tellComB', (msg) =\u003e { this.msg = msg }) } }, comA: { template: '\u003cbutton @click=\"emitFn\"\u003e告诉B\u003c/button\u003e', methods: { emitFn() { // 触发中间组件中的自定义事件 bus.$emit('tellComB', '土豆土豆我是南瓜') } } } } }) \u003c/script\u003e ","date":"2023-03-06","objectID":"/vue%E7%AC%94%E8%AE%B0/:3:0","tags":["vue"],"title":"vue基础","uri":"/vue%E7%AC%94%E8%AE%B0/"},{"categories":["vue"],"content":"4. slot 通过 标签指定内容展示区域 \u003c!-- html代码 --\u003e \u003cdiv id=\"app\"\u003e \u003chello\u003e \u003c!-- 如果只有一个slot插槽 那么不需要指定名称 --\u003e \u003cp slot=\"插槽名称\"\u003e我是额外的内容\u003c/p\u003e \u003c/hello\u003e \u003c/div\u003e // js代码 new vue({ el : \"#app\", components : { hello : { template : ` \u003cdiv\u003e \u003cp\u003e我是子组件中的内容\u003c/p\u003e \u003cslot name=\"名称\"\u003e\u003c/slot\u003e \u003c/div\u003e ` } } }) ","date":"2023-03-06","objectID":"/vue%E7%AC%94%E8%AE%B0/:4:0","tags":["vue"],"title":"vue基础","uri":"/vue%E7%AC%94%E8%AE%B0/"},{"categories":["vue"],"content":"5. 获取组件/元素refs 说明：vm.$refs 一个对象，持有已注册过 ref 的所有子组件（或HTML元素） 使用：在 HTML元素 中，添加ref属性，然后在JS中通过vm.$refs.属性来获取 注意：如果获取的是一个子组件，那么通过ref就能获取到子组件中的data和methods \u003cdiv id=\"app\"\u003e \u003cdiv ref=\"dv\"\u003e\u003c/div\u003e \u003cmy res=\"my\"\u003e\u003c/my\u003e \u003c/div\u003e \u003c!-- js --\u003e \u003cscript\u003escript\"\u003e new Vue({ el : \"#app\", mounted() { this.$refs.dv //获取到元素 this.$refs.my //获取到组件 }, components : { my : { template: `\u003ca\u003esss\u003c/a\u003e` } } }) \u003c/script\u003e 路由守卫 // src/router/index.js 就是当前项目的路由模块 // 1.导入 Vue 和VueRouter的包 import Vue from 'vue' import VueRouter from 'vue-router' // 导入需要的组件 import Home from '@/components/Home.vue' import Movie from '@/components/Movie.vue' import About from '@/components/About.vue' import Tab1 from '@/components/tabs/Tab1.vue' import Tab2 from '@/components/tabs/Tab2.vue' import Login from '@/components/Login.vue' import Main from '@/components/Main.vue' // 把 VueRouter 安装为 Vue 项目的插件 // Vue.use() 函数的作用，就是来安装插件的 // 2.调用Vue.use()函数 把VueRouter安装为Vue的插件 Vue.use(VueRouter) // 3.创建路由的实例对象 const router = new VueRouter({ // routes 是一个数组，作用：定义 “hash 地址” 与 “组件” 之间的对应关系 routes: [ // 重定向的路由规则 { path: '/', redirect: '/home' }, // 路由规则 { path: '/home', component: Home }, // 需求：在 Movie 组件中，希望根据 id 的值，展示对应电影的详情信息 // 可以为路由规则开启 props 传参，从而方便的拿到动态参数的值 { path: '/movie/:mid', component: Movie, props: true }, { path: '/about', component: About, // redirect: '/about/tab1', children: [ // 子路由规则 // 默认子路由：如果 children 数组中，某个路由规则的 path 值为空字符串，则这条路由规则，叫做“默认子路由” { path: '', component: Tab1 }, { path: 'tab2', component: Tab2 } ] }, { path: '/login', component: Login }, { path: '/main', component: Main } ] }) // 为 router 实例对象，声明全局前置导航守卫 // 只要发生了路由的跳转，必然会触发 beforeEach 指定的 function 回调函数 router.beforeEach(function(to, from, next) { // to 表示将要访问的路由的信息对象 // from 表示将要离开的路由的信息对象 // next() 函数表示放行的意思 // 分析： // 1. 要拿到用户将要访问的 hash 地址 // 2. 判断 hash 地址是否等于 /main。 // 2.1 如果等于 /main，证明需要登录之后，才能访问成功 // 2.2 如果不等于 /main，则不需要登录，直接放行 next() // 3. 如果访问的地址是 /main。则需要读取 localStorage 中的 token 值 // 3.1 如果有 token，则放行 // 3.2 如果没有 token，则强制跳转到 /login 登录页 if (to.path === '/main') { // 要访问后台主页，需要判断是否有 token const token = localStorage.getItem('token') if (token) { next() } else { // 没有登录，强制跳转到登录页 next('/login') } } else { next() } }) // 4.向外共享路由的实例对象 export default router 数据类型转换 /整数/parseInt(string) /分数/parseFloat(string) /Number/Number(val) 保留几位小数在方法后面加.toFixed()，比如去分数保留2位小数parseFloat(string).toFixed(2)； 登陆前后 页面显示不同 (1)在父组件App.vue的底部导航栏组件渲染标签处引入或者标签实现导航栏的显示与隐藏状态【】，首先设置一个showNav标志，未登录时showNav值为false【showNav: false】，导航栏不显示。 （2）在子组件Login.vue页面，当登录成功，设置showNav值为true，【this.$parent.showNav = true;】导航栏显示。 （3）另外，在登录成功之后跳转的每一个页面中的【created】中设置showNav值为true 实际项目 \u003ctemplate\u003e \u003cdiv class=\"top-nav\"\u003e \u003cdiv class=\"log\" @click=\"gotoHome\" title=\"去首页\"\u003e \u003cimg style=\"width: 50px; height: 50px\" src=\"@/assets/images/logo.png\" /\u003e 深地探测科学数据中心 \u003c/div\u003e \u003cel-menu :active-text-color=\"variables.menuActiveText\" :default-active=\"activeMenu\" mode=\"horizontal\" @select=\"handleSelect\" \u003e \u003cdiv v-for=\"item in routes\" :key=\"item.path\" class=\"nav-item\"\u003e \u003capp-link :to=\"resolvePath(item)\"\u003e \u003cel-menu-item v-if=\"!item.hidden\" :index=\"item.path\"\u003e{{ item.meta ? item.meta.title : item.children[0].meta.title }}\u003c/el-menu-item\u003e \u003c/app-link\u003e \u003c/div\u003e \u003c/el-menu\u003e \u003cdiv class=\"right-menu\" style=\"margin-right: 20px\"\u003e \u003cimg style=\"width: 30px; height: 30px\" src=\"@/assets/images/user.png\" class=\"user-avatar\" /\u003e \u003cel-dropdown v-if=\"token\" class=\"avatar-container\" trigger=\"click\"\u003e \u003cdiv class=\"avatar-wrapper\"\u003e \u003cspan style=\"color: #fff; cursor: pointer\"\u003e{{ username }}\u003c/span\u003e \u003ci class=\"el-icon-arrow-down\" style=\"cursor: pointer\" /\u003e \u003c/div\u003e \u003cel-dropdown-menu slot=\"dropdown\" class=\"user-dropdown\"\u003e \u003c!-- \u003crouter-link @click.native=\"toHome\" to=\"/\"\u003e \u003cel-dropdown-item\u003e进入首页\u003c/el-dropdown-item\u003e \u003c/router-link\u003e --\u003e \u003c!-- \u003crouter-link @click.native=\"toPersonalCenter\" to=\"/user\"\u003e \u003cel-dropdown-item\u003e个人资料\u003c/el-dropdown-item\u003e \u003c/router-link\u003e --\u003e \u003crouter-link v-show=\"token\" @click.native=\"toApplit\" to=\"/user/fetch-list\" \u003e \u003cel-dropdown-item\u003e申请列表\u003c/el-dropdown-item\u003e \u003c/router-link\u003e \u003cel-dropdown-item divided @click.native=\"logout\"\u003e \u003cspan","date":"2023-03-06","objectID":"/vue%E7%AC%94%E8%AE%B0/:5:0","tags":["vue"],"title":"vue基础","uri":"/vue%E7%AC%94%E8%AE%B0/"},{"categories":["vue"],"content":"生命周期 \u003ctemplate\u003e \u003cdiv\u003e \u003ch2\u003evue3的生命周期\u003c/h2\u003e \u003cdiv id=\"dom\"\u003e{{ msg }}--{{ num }}\u003c/div\u003e \u003c!-- v-on:事件名=\"事件方法\" 绑定事件 简写@:事件名=\"事件方法\" --\u003e \u003c!-- 事件及方法直接声明在 setup内--\u003e \u003cbutton v-on:click=\"handleClick\"\u003eclick me\u003c/button\u003e \u003chr /\u003e \u003c!-- v-model 双向绑定 --\u003e \u003c!-- input：输入事件 blur:失去焦点 focus:获取焦点 change：内容更改 --\u003e \u003cinput type=\"text\" placeholder=\"请输入姓名\" v-model=\"userName\" /\u003e\u003cbr /\u003e \u003cinput type=\"text\" placeholder=\"请输入电话\" v-model=\"userPhone\" @focus=\"handleFocus\" @blur=\"handleBlur\" @input=\"handleInput\" @change=\"handleChange\" /\u003e\u003cbr /\u003e \u003ctextarea placeholder=\"请输入您的建议\" cols=\"30\" rows=\"10\" v-model=\"userInput\" \u003e\u003c/textarea\u003e \u003cp\u003e{{ userName }}---{{ userInput }}\u003c/p\u003e \u003cbutton @click=\"submit\"\u003e提交\u003c/button\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import { reactive, toRefs, onBeforeMount, onMounted, onBeforeUpdate, onUpdated } from 'vue' export default { name: 'about', setup() { const data = reactive({ msg: '你好！', msg2: 'hello world', num: 0, userName: '', userInput: '', userPhone: '' }) // 数据渲染前 onBeforeMount(() =\u003e { console.log('onBeforeMount', document.querySelector('#dom')) }) // 数据渲染后 onMounted(() =\u003e { console.log('onMounted', document.querySelector('#dom')) setTimeout(() =\u003e { data.msg = 'hello' // data.msg2=\"hello\" }, 2000) }) // dom更新前 onBeforeUpdate(() =\u003e { console.log('onBeforeUpdate') }) // dom更新前 onUpdated(() =\u003e { console.log('onUpdated') // data.num+=1;//出发死循环 }) // 事件及方法 const handleClick = () =\u003e { alert('你好') } const submit = () =\u003e { alert(`${data.userName}的建议是${data.userInput}`) } const handleFocus = () =\u003e { console.log('获取焦点了') } const handleBlur = () =\u003e { return } const handleInput = () =\u003e { // 正则验证手机号 return } const handleChange = () =\u003e { // 正则验证手机号 if (!/^[1][3,4,5,7,8][0-9]{9}$/.test(data.userPhone)) { console.log('不符合手机号') } else { console.log('符合手机号') } } return { ...toRefs(data), handleClick, submit, handleFocus, handleBlur, handleInput, handleChange } } } \u003c/script\u003e 生命周期 Vue生命周期函数就是vue实例在某一个时间点会自动执行的函数 beforeCreate（）{}：Vue创建前，此阶段为实例初始化之后，this指向创建的实例，数据观察,数据监听事件机制都未形成，不能获得DOM节点。data，computed，watch，methods 上的方法和数据均不能访问，注：date和methods的数据都还未初始化。 当Vue对象创建之前触发的函数（beforeCreate） Created（）{}： 已经在内存中创建好了，data和methods都可以使用 但还没有编译模版 Vue创建后，此阶段为实例初始化之后，data、props、computed的初始化导入完成， 注：要调用methods中的方法，或者操作data中的数据，最早只能在Created中操作能访问 data computed watch methods 上的方法和数据，初始化完成时的事件写这个里面，此阶段还未挂载DOM。 ​ Vue对象创建完成触发的函数(Created) beforeMount（）{}: Vue载入前，阶段执行时， 模板已经在内存中编译好了，但是未挂载到页面中，（页面还是旧的） 注：这个阶段是过渡性的，一般一个项目只能用到一两次。 ​ 当Vue对象开始挂载数据的时候触发的函数(beforeMount) Mounted（）{}：编译好模版 挂载到了页面指定的容器中显示数据 Vue载入后，(完成创建vm.$el，和双向绑定)； 只要执行完mounted,就表示整个Vue实例已经初始化完成了，此时组件已经脱离里了创建阶段， 进入到了运行阶段。 ​ 当Vue对象挂载数据的完成的时候触发的函数(Mounted) beforeUpdate（）{}:Vue更新前， 当执行beforeUpdate的时候，页面中显示的数据还是旧的，此时date数据是最新的，页面尚未和最新数据数据保持同步。但是DOM中的数据会改变，这是vue双向数据绑定的作用，可在更新前访问现有的DOM，如手动移出添加的事件监听器。 ​ Vue对象中的data数据发生改变之前触发的函数 (beforeUpdate) Updated（）{}：Vue更新后， Updated执行时数据已经保持同步了，都是最新的，完成虚拟DOM的重新渲染和打补丁。 组件DOM已完成更新，可执行依赖的DOM操作。 Vue对象中的data数据发生改变完成触发的函数(Updated) 注意：不要在此函数中操作数据（修改属性），否则就会陷入死循环。 beforeDestroy（）{}：（Vue销毁前，可做一些删除提示，比如：您确定删除****吗？）当执行beforeDestroy的时候，Vue实例就已经从运行阶段进入到销毁阶段了。实例上的所有date和methods以及过滤器和指令都是处于可用状态，此时还没有真正的执行销毁过程。 ​ Vue对象销毁之前触发的函数 (beforeDestroy) Destroyed（）{}：Vue销毁后, 当执行到destroted函数的时候，组件已经完全销毁（渣都不剩），此时组件中的所有的数据，方法，指令，过滤器…都已经销毁（不可用了）。 Vue对象销毁完成触发的函数(Destroy) 建立前后 \u003cdiv id=\"root\"\u003e\u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e var vm=new Vue({ el:\"#root\", beforeCreate:function(){//01 建立之前 console.log(\"before create\"); }, created:function(){ console.log(\"created\");//02 建立之后 } }) \u003c/script\u003e 有模板的渲染情况(按模板渲染) \u003cdiv id=\"root\"\u003e\u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e var vm=new Vue({ el:\"#root\", data:{}, beforeCreate:function(){ console.log(\"before create\"); }, created:function(){ console.log(\"created\"); }, template:'\u003ch1\u003e123\u003c/h1\u003e',//如果有模板的话模板替换 EL }) \u003c/script\u003e 02-1 无模板的渲染情况(按挂载元素渲染) \u003cdiv id=\"root\"\u003e{{message}}\u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e var vm=new Vue({ el:\"#root\", data:{ message:\"hello vue!\" }, beforeCreate:function(){ console.log(\"before create\"); }, created:function(){ console.log(\"created\"); }, //如果无模板则用默认的 el 作为挂载点的模板 /*template:'\u003ch1\u003e123","date":"2023-03-06","objectID":"/vue%E7%AC%94%E8%AE%B0/:6:0","tags":["vue"],"title":"vue基础","uri":"/vue%E7%AC%94%E8%AE%B0/"},{"categories":["vue"],"content":"router-view router-link \u003c!-- 相当a标签,to=\"路由path\" --\u003e \u003c!-- \u003cnav\u003e \u003crouter-link to=\"/\"\u003eHome\u003c/router-link\u003e | \u003crouter-link to=\"/about\"\u003eAbout\u003c/router-link\u003e \u003c/nav\u003e --\u003e \u003c!-- router-view:展示路由对应的组件内容 --\u003e \u003crouter-view/\u003e main.js import { createApp } from 'vue' import App from './App.vue' import router from './router' import store from './store' import ElementPlus from 'element-plus' import 'element-plus/dist/index.css' import * as ElementPlusIconsVue from '@element-plus/icons-vue' const app =createApp(App) // element icon 注册 for (const [key, component] of Object.entries(ElementPlusIconsVue)) { app.component(key, component) } app.use(store).use(router).use(ElementPlus).mount('#app') store/index.js import { createStore } from 'vuex' import uInfo from './state/userinfo.state.js' export default createStore({ // 数据比较多,分模块 modules: { uInfo } }) store/state/userinfo.js //登陆 export default{ //保存登陆后的密码 账号数据 state:{ userInfo:(localStorage.getItem(\"loginData\")\u0026\u0026JSON.parse(localStorage.getItem(\"loginData\")))||{} }, mutations:{ setUserInfo(state,uInfo){ state.userInfo=uInfo } } } 退出操作 \u003cel-button @click=\"loginOut\"\u003e退出\u003c/el-button\u003e const loginOut=()=\u003e{ localStorage.removeItem(\"loginData\") store.commit('setUserInfo', {}); router.push({ path:\"/login\" }) } Axios 封装 ","date":"2023-03-06","objectID":"/vue%E7%AC%94%E8%AE%B0/:7:0","tags":["vue"],"title":"vue基础","uri":"/vue%E7%AC%94%E8%AE%B0/"},{"categories":["vue"],"content":"util/service.js import axios from \"axios\" import { ElLoading } from 'element-plus' import { ElMessage } from 'element-plus' import store from \"../store/index.js\" // 使用create创建axios实例 let loadingObj = null const Service = axios.create({ timeout:8000, baseURL:\"http://127.0.0.1:8888/api/private/v1/\", headers:{ \"Content-type\":\"application/json;charset=utf-8\", \"Authorization\":store.state.uInfo.userInfo.token } }) // 请求拦截-增加loading,对请求做统一处理 Service.interceptors.request.use(config=\u003e{ loadingObj=ElLoading.service({ lock: true, text: 'Loading', background: 'rgba(0, 0, 0, 0.7)', }) return config }) // 响应拦截-对返回值做统一处理 Service.interceptors.response.use(response=\u003e{ loadingObj.close() const data = response.data if(data.meta.status!=200 \u0026\u0026 data.meta.status!=201){ ElMessage.error(data.meta.msg||\"服务器出错\") // 请求出错 return data } return data },error=\u003e{ loadingObj.close() ElMessage({ message:\"服务器错误\", type:\"error\", duration:2000 }) }) // post请求 export const post=config=\u003e{ return Service({ ...config, method:\"post\", data:config.data }) } // get请求 export const get=config=\u003e{ return Service({ ...config, method:\"get\", params:config.data }) } // put请求 export const put=config=\u003e{ return Service({ ...config, method:\"put\", data:config.data }) }// delete请求 export const del=config=\u003e{ return Service({ ...config, method:\"delete\" }) } ","date":"2023-03-06","objectID":"/vue%E7%AC%94%E8%AE%B0/:8:0","tags":["vue"],"title":"vue基础","uri":"/vue%E7%AC%94%E8%AE%B0/"},{"categories":["vue"],"content":"util/request.js import {post,get,put,del} from \"./service\" export const loginApi=data=\u003e{ return post({ url:\"/login\", data }) } // 获取用户列表 export const userListApi=data=\u003e{ return get({ url:\"/users\", data }) } // 新增用户列表 export const userAddApi=data=\u003e{ return post({ url:\"/users\", data }) } // 用户列表更改状态 export const userChangeStateApi=data=\u003e{ return put({ url:`users/${data.id}/state/${data.mg_state}`, data }) } // 更改用户信息 export const userChangeInfoApi=data=\u003e{ return put({ url:`users/${data.id}`, data }) } // 删除用户 export const userDeleteApi=data=\u003e{ return del({ url:`users/${data.id}` }) } // 获取角色 export const getRolesApi=data=\u003e{ return get({ url:`roles`, data }) } // 新建角色 export const addRolesApi=data=\u003e{ return post({ url:`roles`, data }) } // 编辑角色 export const editRolesApi=data=\u003e{ return put({ url:`roles/${data.id}`, data }) } export const rolesDeleteApi=data=\u003e{ return del({ url:`roles/${data.id}` }) } export const goodsListApi=data=\u003e{ return get({ url:`goods`, data }) } 在应用到的页面上直接采用此方法 login.vue const handleLogin=()=\u003e{ // 请求后台接口 // 默认用户：admin/123456 loginApi(data.loginData).then(res=\u003e{ if(res.data){ store.commit('setUserInfo', res.data); localStorage.setItem(\"loginData\",JSON.stringify(res.data)) // 跳转/user router.push({ path:\"/\" }) } }) } 表单的正则表达式 \u003c!-- 编辑弹窗 --\u003e \u003cel-dialog v-model=\"dialogFormEVisible\" title=\"编辑用户\"\u003e \u003cel-form ref=\"userForm\" :model=\"formData2\" :rules=\"rules2\" \u003e \u003cel-form-item label=\"邮箱\" prop=\"email\"\u003e \u003cel-input v-model=\"formData2.email\" placeholder=\"请输入用户邮箱\" /\u003e \u003c/el-form-item\u003e \u003cel-form-item label=\"手机号\" prop=\"mobile\"\u003e \u003cel-input v-model=\"formData2.mobile\" placeholder=\"请输入用户手机号\" /\u003e \u003c/el-form-item\u003e \u003c/el-form\u003e \u003ctemplate #footer\u003e \u003cdiv class=\"flex\"\u003e \u003cel-button\u003e取消\u003c/el-button\u003e \u003cel-button type=\"primary\" @click=\"submitForm(userForm)\" \u003e确定\u003c/el-button\u003e \u003c/div\u003e \u003c/template\u003e \u003c/el-dialog\u003e import { toRefs,reactive,ref } from 'vue' export default { setup() { formData2:{ id:\"\", email:\"\", mobile:\"\", }, } } rules:{ username:[ {required:true,message:\"此项为必填\",trigger:\"blur\"} ], password:[ {required:true,message:\"此项为必填\",trigger:\"blur\"} ], email:[ {required:false, pattern:/^[A-Za-z0-9\\u4e00-\\u9fa5]+@[a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)+$/, message:\"请填写正确邮箱\",trigger:\"blur\"} ], mobile:[ {required:false, pattern:/^[1][3,4,5,6,7,8][0-9]{9}$/, message:\"请填写正确手机号\",trigger:\"blur\"} ] } 获取用户列表 reques.js // 获取用户列表 export const userListApi=data=\u003e{ return get({ url:\"/users\", data }) } 页面 \u003c!-- 表格 --\u003e \u003cel-table :data=\"userList\" style=\"width: 100%\"\u003e \u003cel-table-column prop=\"username\" label=\"姓名\" width=\"180\" /\u003e \u003cel-table-column prop=\"mg_state\" label=\"状态\" \u003e \u003ctemplate #default=\"scope\"\u003e \u003cel-switch v-model=\"scope.row.mg_state\" @change=\"switchChange(scope.row)\" /\u003e \u003c/template\u003e \u003c/el-table-column\u003e \u003cel-table-column label=\"操作\" \u003e \u003ctemplate #default=\"scope\"\u003e \u003cel-button type=\"primary\" @click=\"editRow(scope.row)\"\u003e编辑\u003c/el-button\u003e \u003cel-button type=\"danger\" @click=\"deleteRow(scope.row)\"\u003e删除\u003c/el-button\u003e \u003c/template\u003e \u003c/el-table-column\u003e \u003c/el-table\u003e userList:[], const searchList=()=\u003e{ userListApi(data.searchParams).then(res=\u003e{ if(res.data){ // console.log(\"用户数据\",res) data.userList=res.data.users data.total=res.data.total } }) } // 方法初始化 searchList() return{ ... toRefs(data), searchList, 搜索用户 request.js // 获取用户列表 export const userListApi = data =\u003e { return get({ url: '/users', data }) } 页面 \u003cel-input v-model=\"searchParams.query\" placeholder=\"搜索关键字\" class=\"input-with-select\"\u003e \u003ctemplate #append\u003e \u003cel-button @click=\"searchList\"\u003e\u003cel-icon\u003e\u003cSearch /\u003e\u003c/el-icon\u003e\u003c/el-button\u003e \u003c/template\u003e \u003c/el-input\u003e const searchList = () =\u003e { userListApi(data.searchParams).then(res =\u003e { if (res.data) { // console.log('用户数据', res) data.userList = res.data.users data.total = res.data.total } }) } 添加用户 写借口的时候 先找request。j s--------get post 需要的页面上 import 引进对应的API from request request.js // 新增用户列表 export const userAddApi=data=\u003e{ return post({ url:\"/users\", data }) } // 新增提交 const addUser=()=\u003e{ data.dialogFormVisible=true } const submitForm=(formEl)=\u003e{ // validate formEl.validate(res=\u003e{ if(!res){ return } // 表单通过请求接口 userAddApi(data.","date":"2023-03-06","objectID":"/vue%E7%AC%94%E8%AE%B0/:9:0","tags":["vue"],"title":"vue基础","uri":"/vue%E7%AC%94%E8%AE%B0/"},{"categories":["vue"],"content":"vue3 \u003c!-- 分页 vue3--\u003e \u003cel-pagination v-model:currentPage=\"searchParams.pagenum\" v-model:page-size=\"searchParams.pagesize\" :page-sizes=\"[2,5,10,20]\" :small=\"small\" layout=\"total, sizes, prev, pager, next, jumper\" :total=\"total\" @size-change=\"searchList\" @current-change=\"searchList\" /\u003e searchParams:{ query:\"\", pagesize:5, pagenum:1 }, total:0, const searchList=()=\u003e{ userListApi(data.searchParams).then(res=\u003e{ if(res.data){ // console.log(\"用户数据\",res) data.userList=res.data.users data.total=res.data.total } }) ","date":"2023-03-06","objectID":"/vue%E7%AC%94%E8%AE%B0/:10:0","tags":["vue"],"title":"vue基础","uri":"/vue%E7%AC%94%E8%AE%B0/"},{"categories":["vue"],"content":"vue2 \u003cel-pagination @size-change=\"handleSizeChange\" @current-change=\"handleCurrentChange\" :current-page=\"queryInfo.pagenum\" :page-sizes=\"[1, 2, 5, 10]\" :page-size=\"queryInfo.pagesize\" layout=\"total, sizes, prev, pager, next, jumper\" :total=\"total\"\u003e \u003c/el-pagination\u003e // 获取用户列表的参数对象 queryInfo: { query: '', // 当前的页数 pagenum: 1, // 当前每页显示多少条数据 pagesize: 2 }, total: 0, // 监听 pagesize 改变的事件 handleSizeChange(newSize) { // console.log(newSize) this.queryInfo.pagesize = newSize this.getUserList() }, // 监听 页码值 改变的事件 handleCurrentChange(newPage) { console.log(newPage) this.queryInfo.pagenum = newPage this.getUserList() }, 商品状态 ","date":"2023-03-06","objectID":"/vue%E7%AC%94%E8%AE%B0/:11:0","tags":["vue"],"title":"vue基础","uri":"/vue%E7%AC%94%E8%AE%B0/"},{"categories":["vue"],"content":"vue3 表格 \u003cel-table :data=\"goodsList\" style=\"width: 100%\"\u003e \u003cel-table-column prop=\"goods_state\" label=\"商品状态\" \u003e \u003ctemplate #default=\"scope\"\u003e \u003cp\u003e{{switchState(scope.row.goods_state)}}\u003c/p\u003e \u003c/template\u003e \u003c/el-table-column\u003e \u003c/el-table\u003e const switchState=state=\u003e{ switch (state) { case 0: return \"未通过\" break; case 1: return \"审核中\" break; case 2: return \"已审核\" break; } } // 方法初始化 searchList() return{ switchState } ","date":"2023-03-06","objectID":"/vue%E7%AC%94%E8%AE%B0/:12:0","tags":["vue"],"title":"vue基础","uri":"/vue%E7%AC%94%E8%AE%B0/"},{"categories":["vue"],"content":"vue2 \u003cel-table-column label=\"商品状态\" prop=\"goods_state\" width=\"80px\"\u003e \u003ctemplate v-slot=\"scope\"\u003e \u003cel-tag v-if=\"scope.row.goods_state === '0'\"\u003e通过\u003c/el-tag\u003e \u003cel-tag type=\"success\" v-else-if=\"scope.row.goods_state === '1'\" \u003e审核中\u003c/el-tag \u003e \u003cel-tag type=\"success\" v-else\u003e已审核\u003c/el-tag\u003e \u003c/template\u003e \u003c/el-table-column\u003e 22222222222222222222222222222 1. Vuex的基本使用 安装vuex依赖包 npm install vuex –save 导入vuex包 在main.js 使用 import Vue from \"vue\"; import App from './App.vue' import store from './store' Vue.config.productionTip = false Vue.phototype.$store=store new Vue({ store, render: h =\u003e h(App) }).$mount('#app') 创建store对象 store.js import Vue from 'vue' import Vuex, {mapGetters, mapMutations, mapState} from 'vuex' Vue.use(Vuex) //vuex的插件机制 const store = new Vuex.Store({ // state中存放的就是全局共享的数据 state: {count: 0} }) 将store对象挂载到vue实例中 new Vue({ el: '#app', render: h =\u003e h(app), router, // 将创建的共享数据对象，挂载到Vue实例中 // 所有的组件，就可以直接从store中获取全局的数据了 store }) 2.Vuex的核心概念 Vuex中的主要核心概念如下： State Mutation Action Getter ","date":"2023-03-06","objectID":"/vue%E7%AC%94%E8%AE%B0/:13:0","tags":["vue"],"title":"vue基础","uri":"/vue%E7%AC%94%E8%AE%B0/"},{"categories":["vue"],"content":"2.1 State 在Vuex中，State提供唯一的公共数据源，所有共享的数据都要统一放到Store的State中进行存储，这里的Store相当于一个用于存储数据的公共容器。 const store = new Vue.Store({ state: { count: 0 } ... }) export default new Vuex.Store({ state: { count: 0 } }) 1.组件访问State中数据的第一种方式 this.$store.state.全局数据名称 去过是在html元素组件之间调用，则可以省略this，即： \u003ch3\u003e当前最新的count值：{{$store.state.count}}\u003c/h3\u003e ​ 2.组件访问State中数据的第二种方式 通过mapState辅助函数方式，实现组件访问State中数据的第二种方式 // 1. 从vuex中按需导入mapState函数 import { mapState } from 'vuex' 通过刚才导入的mapState函数，将当前组件需要的全局数据，映射为当前的computed计算属性： //将全局数据映射为当前组件的计算属性 computed: { // ...表示展开映射，意思就是将全局属性映射为当前组件的计算属性 ...mapState(['count']) } 直接在调用获取组件属性 \u003cspan\u003e{{count}}\u003c/span\u003e ","date":"2023-03-06","objectID":"/vue%E7%AC%94%E8%AE%B0/:14:0","tags":["vue"],"title":"vue基础","uri":"/vue%E7%AC%94%E8%AE%B0/"},{"categories":["vue"],"content":"2.2 Mutation Vuex中的Mutation是用于变更Store中的数据。 在Vuex中，只能通过mutation变更Store数据，不可以直接操作Store中的数据。虽然通过mutation的方式来操作数据，虽然繁琐了一点，但是却可以集中监控所有数据的变化。 例如需要让全局数据自增加1，则可以通过如下的方式在Mutation中定义 const store = new Vuex.Store({ state: { count: 0 }, mutations: { add(state) { //变更状态 state.count++; } } }) 定义完mutation之后，下面就来介绍下Vuex的触发方式 触发mutation方式一 通过$store.commit()函数来触发mutation。 methods: { handle1 () { // 触发mutations的第一种方式 this.$store.commit('add') } } //接着就可以通过@click方法来调用handle1，从而来触发mutation函数。 //另外，可以在触发mutation函数时，传入参数 const store = new Vuex.Store({ state: { count: 0 }, mutations: { add(state) { //变更状态 state.count++; }, addN(state, n) { state.count += n; } } }) //然后定义handler2 methods: { handler2: { this.$store.commit('addN', 5); } } 触发mutation方式二 通过导入mapMutations辅助函数来触发mutations。 // 1. 从vuex中按需导入mapMutations函数 import { mapMutations } from 'vuex' ... // 2. 将制定的mutations函数映射为当前组件的methods函数 methods: { // 将add和addN方法映射为methods中的函数，拱当前组件使用。 ...mapMutations({'add', 'addN'}), handleAdd() { this.add(); }, handleAddN(n) { this.addN(n); } // 或者直接在标签元素中直接@click=add(n) } 对于mutations来说，只能够实现同步操作，不可以执行异步操作的。 ","date":"2023-03-06","objectID":"/vue%E7%AC%94%E8%AE%B0/:15:0","tags":["vue"],"title":"vue基础","uri":"/vue%E7%AC%94%E8%AE%B0/"},{"categories":["vue"],"content":"2.3 Action 从vuex官网中可以了解到，Action类似于mutation，不同之处在于： Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 可以得出一个结论就是，如果通过异步操作变更数据，必须通过Action，而不能使用Mutation，但是在Action中还是要通过触发Mutation的方式间接变更数据。 //定义Actions const store = new Vuex.Store({ state: { count: 0 }, mutations: { add(state) { //变更状态 state.count++; }, addN(state, n) { state.count += n; } }, actions: { // 通过context去调用mutation addAsync(context) { setTimeout(() =\u003e { // 在action中，不能直接更改 state中的数据 // 必须通过 context.commit() 触发某个mutation才行 context.commit('add') }, 1000) }, // 调用Actions是也可以传入参数 addNAsync(context, n) { setTimeout(() =\u003e { context.commit('addN', n); }, 1000); } } }) 需要再次强调的是，只有通过mutation中定义的函数，才有权利去修改state中的数据，因此actions最终还是要调用mutation。 触发Actions的第一种方式 methods: { handleAddAsync() { this.$store.dispatch('addAsync'); }, handleAddNAsync() { this.$store.dispatch('addNAsync', n); } } 触发Actions的第二种方式 可以通过mapActions辅助函数的方式来触发Actions。 // 1. 从vuex中按需导入mapActions函数 import { mapActions } from 'vuex' ... // 2. 将指定的actions函数，映射为当前组件的methos函数 methods: { ...mapActions(['addAsync', 'addNAsync'), handleAddAsync() { this.addAsync(); }, handleAddNAsync(n) { this.addNAsync(n); } } ","date":"2023-03-06","objectID":"/vue%E7%AC%94%E8%AE%B0/:16:0","tags":["vue"],"title":"vue基础","uri":"/vue%E7%AC%94%E8%AE%B0/"},{"categories":["vue"],"content":"2.4 Getter 在Vuex官网中，用到了派生这一词来介绍Getter，在这里可以理解为就是用于对Store中的数据进行加工处理，形成新的数据，类似Vue的计算属性。Getter的数据是基于Store中的数据的，所以当Store中数据发生变化时，Getter中的数据也会随之变化。 定义Getter 例如state中存有todos计划项，其对象有一个done状态表示完成与否。 const store = new Vuex.Store({ state: { todos: [ { id: 1, text: '...', done: true }, { id: 2, text: '...', done: false } ] }, 加减法里的getters getters: { showNum(state){ return '当前最新的数据量是 【'+state.count+'】' } }, getters: { // 这里通过getters定义的doneTodos方法来过滤已完成的todo项 doneTodos: state =\u003e { return state.todos.filter(todo =\u003e todo.done); }, // 这里还可以通过传入getters对象来获取其他方法 doneTodosCount: (state, getters) =\u003e { return getters.doneTools.length; }, // 传入参数 getTodoById: (state) =\u003e (id) =\u003e { return state.todos.find(todo =\u003e todo.id == id); } } }) 触发Getter定义函数的第一种方法 this.$store.getters.doneTodos // -\u003e [{id: 1, text: '...', done: true}] this.$store.getters.doneTodosCount // -\u003e 1 触发Getter定义函数的第二种方法 通过mapGetters来触发Getter中定义的函数 // 1. 导入mapGetters辅助函数 import { mapGetters } from 'vuex' ... // 2. 将制定的Getters函数映射为当前组件的函数 computed: { ...mapGetters(['doneTodos', 'doneTodosCount']), handleDoneTodos() { this.doneTodos(); } } computed:{ ...mapGetters(['showNum']) } ","date":"2023-03-06","objectID":"/vue%E7%AC%94%E8%AE%B0/:17:0","tags":["vue"],"title":"vue基础","uri":"/vue%E7%AC%94%E8%AE%B0/"},{"categories":["vue"],"content":"2.5 Module 当Store中存放了非常多非常大的共享数据对象时，应用会变的非常的复杂，Store对象也会非常臃肿，所以Vuex提供了一个Module模块来分隔Store。通过对Vuex中的Store分隔，分隔成一个一个的Module模块，每个Module模块都拥有自己的state、mutation、actions和getters。 const moduleA = { state: () =\u003e ({ ... }), mutations: { ... }, actions: { ... }, getters: { ... } } const moduleB = { state: () =\u003e ({ ... }), mutations: { ... }, actions: { ... } } const store = new Vuex.Store({ modules: { a: moduleA, b: moduleB } }) store.state.a // -\u003e moduleA 的状态 store.state.b // -\u003e moduleB 的状态 对于模块中的mutations和getters，传入的第一个参数规定为state，而actions则依旧是context参数。如下： const moduleA = { state: { count: 0 }, mutations: { increment (state) { // 这里的 `state` 对象是模块的局部状态 state.count++ } }, getters: { doubleCount (state) { return state.count * 2 } }, actions: { // context对象其实包含了 state、commit、rootState。 incrementIfOddRootsum (context) { if ((context.state.count + context.rootState.count) % 2 === 1) { // 调用mutations commit('increment') } } } } 在module中通过mapState、mapGetters、mapActions和mapMutations等辅助函数来绑定要触发的函数 第一种方式 methods: { ...mapActions([ 'some/nested/module/foo', 'some/nested/module/bar' ]) } 在vuex中，可以为导入的state、getters、actions以及mutations命名别名，，这样可以方便调用 methods: { ...mapActions([ 'foo': 'some/nested/module/foo', 'bar': 'some/nested/module/bar' ]) } 第二种方式 对于这种情况，你可以将模块的空间名称字符串作为第一个参数传递给上述函数，这样所有绑定都会自动将该模块作为上下文。于是上面的例子可以简化为： methods: { ...mapActions('some/nested/module', [ 'foo', // -\u003e this.foo() 'bar' // -\u003e this.bar() ]) } 第三种方式 可以通过使用 createNamespacedHelpers 创建基于某个命名空间辅助函数。它返回一个对象，对象里有新的绑定在给定命名空间值上的组件绑定辅助函数： import { createNamespacedHelpers } from 'vuex' const { mapState, mapActions } = createNamespacedHelpers('some/nested/module') export default { methods: { // 在 `some/nested/module` 中查找 ...mapActions([ 'foo', 'bar' ]) } } 封装vuex在项目中的使用（公司） gettings.js 接下来定义状态state各个字段的获取方法。 export default { opened: (state) =\u003e state.app.slider.opened, token: (state) =\u003e state.app.token, uname: (state) =\u003e state.app.uname, menuList: (state) =\u003e state.app.menuList, permissionList: (state) =\u003e state.app.permissionList, }; import { TOGGLE_SLIDER, SET_TOKEN, SET_UNAME, SET_MENU_LIST, SET_PERMISSION_LIST, SET_ACTIVE, SET_MENU, SET_TASK_ID, SET_FORMDATA, SET_FILE } from \"./type.js\"; export default { namespaced: true, state: { slider: { opened:JSON.parse(sessionStorage.getItem(\"opened\")), }, token: sessionStorage.getItem(\"token\") || \"\", menuList: null, permissionList: [], uname: sessionStorage.getItem(\"uname\") || \"\", componentsActive: 'serviceMain', userId: sessionStorage.getItem(\"userId\") || \"\", sideMenuList: [ { name: \"服务内容\", img: \"\", route: \"serviceMain\", router: 'service-subscriptions' }, { name: \"任务创建\", img: \"\", route: \"taskMain\", router: 'service-subscriptions' } ], taskId: sessionStorage.getItem(\"taskId\") || \"\", fileListObj: {}, firstFormData: { name: \"\", description: \"\", hasInsar: false, hasAi: false, }, secondFormData: { taskId: \"\", satelliteName: \"\", monitorStartTime: \"\", monitorEndTime: \"\", demResolution: \"\", hasAnomalyRegion: false, hasDeformationRate: false, hasAccumulatedDeformation: false, hasDiagram: false, }, thirdFormData: { taskId: \"\", hasTargetGeohazard: false, hasTargetHazardBody: false, cognitionModel: 0, satelliteName: \"\", preStartTime: \"\", preEndTime: \"\", postStartTime: \"\", postEndTime: \"\", cloudCover: 0, }, finalFormData: { taskId: \"\", name: \"\", department: \"\", phone: \"\", email: \"\", }, dataDetail: null, tableName: null }, 定义一些修改state的操作方法。 mutations: { [TOGGLE_SLIDER](state) { state.slider.opened = !state.slider.opened; sessionStorage.setItem( \"opened\", JSON.stringify(state.slider.opened) ); }, [SET_TOKEN](state, token) { state.token = token; sessionStorage.setItem(\"token\", state.token); }, [SET_UNAME](state, uname) { state.uname = uname; sessionStorage.setItem(\"uname\", state.uname); }, [SET_MENU_LIST](state, menuList) { state.menuList = menuList; }, [SET_PERMISSION_LIST](state, permissionList) { state.permissionList = permissionList; }, [SET_ACTIVE](state, val) { state.componentsActive = val; }, [SET_MENU](state, val) { state.sideMenuList = val; }, [SET_FILE","date":"2023-03-06","objectID":"/vue%E7%AC%94%E8%AE%B0/:18:0","tags":["vue"],"title":"vue基础","uri":"/vue%E7%AC%94%E8%AE%B0/"},{"categories":["vue"],"content":"提供 用provide和解决道具钻孔问题inject。父组件可以充当其所有后代的依赖提供者。后代树中的任何组件，无论它有多深，都可以注入其父链中组件提供的依赖项。 要向组件的后代提供数据，请使用以下provide()函数： \u003cscript setup\u003e import { provide } from 'vue' provide(/* key */ 'message', /* value */ 'hello!') \u003c/script\u003e 如果不使用\u003cscript setup\u003e，请确保provide()在内部同步调用setup()： import { provide } from 'vue' export default { setup() { provide(/* key */ 'message', /* value */ 'hello!') } } 该provide()函数接受两个参数。第一个参数称为注入密钥，可以是字符串或Symbol. 后代组件使用注入键来查找要注入的所需值。单个组件可以provide()使用不同的注入键多次调用以提供不同的值。 第二个参数是提供的值。该值可以是任何类型，包括反应状态，例如 refs： import { ref, provide } from 'vue' const count = ref(0) provide('key', count) ","date":"2023-03-06","objectID":"/vue%E7%AC%94%E8%AE%B0/:19:0","tags":["vue"],"title":"vue基础","uri":"/vue%E7%AC%94%E8%AE%B0/"},{"categories":["vue"],"content":"应用级提供 除了在组件中提供数据，我们还可以在应用层提供： import { createApp } from 'vue' const app = createApp({}) app.provide(/* key */ 'message', /* value */ 'hello!') ","date":"2023-03-06","objectID":"/vue%E7%AC%94%E8%AE%B0/:20:0","tags":["vue"],"title":"vue基础","uri":"/vue%E7%AC%94%E8%AE%B0/"},{"categories":["vue"],"content":"注入 要注入祖先组件提供的数据，请使用以下inject()函数： \u003cscript setup\u003e import { inject } from 'vue' const message = inject('message') \u003c/script\u003e 如果不使用\u003cscript setup\u003e，inject()则只能在内部同步调用setup()： import { inject } from 'vue' export default { setup() { const message = inject('message') return { message } } } ","date":"2023-03-06","objectID":"/vue%E7%AC%94%E8%AE%B0/:21:0","tags":["vue"],"title":"vue基础","uri":"/vue%E7%AC%94%E8%AE%B0/"},{"categories":["vue"],"content":"注入默认值 默认情况下，inject假定注入的密钥在父链中的某处提供。在未提供密钥的情况下，将出现运行时警告。 如果我们想让注入的属性与可选提供者一起工作，我们需要声明一个默认值，类似于 props： // `value` will be \"default value\" // if no data matching \"message\" was provided const value = inject('message', 'default value') 在某些情况下，可能需要通过调用函数或实例化新类来创建默认值。为了避免在不使用可选值的情况下进行不必要的计算或副作用，我们可以使用工厂函数来创建默认值： const value = inject('key', () =\u003e new ExpensiveClass()) ","date":"2023-03-06","objectID":"/vue%E7%AC%94%E8%AE%B0/:21:1","tags":["vue"],"title":"vue基础","uri":"/vue%E7%AC%94%E8%AE%B0/"},{"categories":["vue"],"content":"使用反应性 当使用反应式提供/注入值时，**建议尽可能将任何突变保留在*提供者***内部的反应状态。这确保了所提供的状态及其可能的变化位于同一个组件中，使将来更容易维护。 有时我们可能需要更新来自注入器组件的数据。在这种情况下，我们建议提供一个负责改变状态的函数： \u003c!-- inside provider component --\u003e \u003cscript setup\u003e import { provide, ref } from 'vue' const location = ref('North Pole') function updateLocation() { location.value = 'South Pole' } provide('location', { location, updateLocation }) \u003c/script\u003e \u003c!-- in injector component --\u003e \u003cscript setup\u003e import { inject } from 'vue' const { location, updateLocation } = inject('location') \u003c/script\u003e \u003ctemplate\u003e \u003cbutton @click=\"updateLocation\"\u003e{{ location }}\u003c/button\u003e \u003c/template\u003e readonly()最后，如果你想确保传递的数据provide不会被注入器组件改变，你可以将提供的值包裹起来。 \u003cscript setup\u003e import { ref, provide, readonly } from 'vue' const count = ref(0) provide('read-only-count', readonly(count)) \u003c/script\u003e ES6 Map Set ","date":"2023-03-06","objectID":"/vue%E7%AC%94%E8%AE%B0/:22:0","tags":["vue"],"title":"vue基础","uri":"/vue%E7%AC%94%E8%AE%B0/"},{"categories":["vue"],"content":"Set Set是ES6中新增的数据结构，它类似于数组，但是Set数据中的元素都是唯一的，没有重复值的; Set构造函数参数：初始化参数的时候，参数必须是实现iterator接口的数据类型，否则会抛出异常； const set = new Set([1,2,3]); const set1 = new Set('1233'); const set2 = new Set(1); //VM387:1 Uncaught TypeError: number 1 is not iterable (cannot read property Symbol(Symbol.iterator)) at new Set (\u003canonymous\u003e) at \u003canonymous\u003e:1:12 // 注意：方法中的参数是元素的值，不是元素的索引 const s = new Set(); s.add(1).add(2).add(3); // 向 set 结构中添加值，可以链式操作 s.delete(2) // 删除 set 结构中的2值 s.has(1) // 表示 set 结构中是否有1这个值 s.clear() // 清除 set 结构中的所有值 s.size() // 统计 Set 中的元素个数 // 将set转化为数组 const arr = Array.from(s) // 遍历set let set=new Set(['red','blue','green']); // 遍历方法1，不常用 for(let key of set.keys()){ console.log(key);//red,blue,green } // 遍历方法2，不常用 for(let value of set.values()){ console.log(value);//red,blue,green } // 遍历方法3，常用 s.forEach(value =\u003e console.log(value)) //red,blue,green 属性和方法 Set.prototype.add()方法 Set.prototype.add(value); 参数1 value：需要添加到set元素中的值，不能够添加重复值； 返回值：返回实例化对象Set本身； var s1 = new Set([1, 2, 3]); var s2 = s1.add(4); console.log(s1); // Set {1, 2, 3, 4} console.log(s1 === s2); // true Set.prototype.has()方法 Set.prototype.has(value)； 参数1 value：必填项，测试该值是否存在Set对象中； 返回值：布尔值，false表示不存在，true表示存在； var s1 = new Set([1, 2, 3, 4]); s1.has(4); // true Set.prototype.size size属性将返回Set对象的元素个数； // add方法可以链式调用 var mySet = new Set(); mySet.add(1).add(2).add(3); mySet.size; // 3 Set.prototype.delete()方法 Set.prototype.delete(value)； 参数1 value：需要删除的元素； 返回值：成功删除返回true，否则返回false； Set.prototype.clear()方法 clear()方法用来清空一个Set对象中的所有元素； Set遍历的方法 Set.prototype.keys()方法，Set.prototype.values()方法，Set.prototype.entires()方法 var s1 = new Set([1, 2, 3]); var iterator = s1.keys(); var iterator = s1.values(); var iterator = s1.entries(); console.log(iterator.next()); keys和values返回的结果相同，Set中的key等于value，这也是新增时add只传一个参数的原因 应用场景 数组去重 var arr = [1, 2, 3, undefined,undefined,null,null, NaN, 1, 2, 3, NaN], set = new Set(arr); console.log([...set]); // 借助Array.from() 或 ...（扩展运算符） let arrs = [1,1,3,3,4,5,6]; let s = new Set(arrs); // 方法1：利用 ... let arr1 = [...s]; // 方法二：利用 Array.from() let arr2 = Array.from(s) console.log(arr1);// 1,3,4,5,6 console.log(arr2);// 1,3,4,5,6 数组去重后的实现映射数组 set实例本身没有map，filter等数组属性 let set = new Set([1,2,3,4,5,6,7]); let set2 = new Set([...set].map(value =\u003e value * 2)); let set = new Set([1,2,3]); let set1 = new Set(Array.from(set, vlaue=\u003evalue * 2)); 数组去重后，过滤返回新的数组 let set = new Set([1,2,3,4,5,6,7,1,2,3]); let set2 = new Set([...set].filter(x =\u003e (x%2) == 0)); 循环递归调用 const s1 = new Set([1]) s1.forEach(item =\u003e {s1.delete(1);s1.add(1);console.log('end')}) //会一直循环调用forEach 里面的代码 不断打印end 数组的交集、并集和差集 let arr1 = [1,2,3]; let arr2 = [4,3,2]; let a=new Set(arr1); let b=new Set(arr2); // 并集 let union=new Set([...a, ...b]); console.log(union);// 1,2,3,4 // 交集(借助数组的filter方法) let intersect=new Set([...a].filter(x=\u003eb.has(x))); console.log(intersect);// 2,3 // 差集(借助数组的filter方法) let difference=new Set([...a].filter(x=\u003e!b.has(x))); console.log(difference);//1 ","date":"2023-03-06","objectID":"/vue%E7%AC%94%E8%AE%B0/:23:0","tags":["vue"],"title":"vue基础","uri":"/vue%E7%AC%94%E8%AE%B0/"},{"categories":["vue"],"content":"map 传统的对象属性键名为字符串，并能够真真正正的实现属性键 — 属性值的对应；ES6Map数据结构实现的出现，实现对象键名与键值一 一对应的关系； // map的基本操作 const map=new Map(); map.set(1,'a').set(2,'b').set(3,'c'); // 链式新增/修改值，前面是键 后面是值 map.get(1); // a 获取键对应的值 value map.has(2); // true 判断某个key是否存在 map.delete(3); // true 删除某个key map.clear(); // 清除map所有成员 map.size(); // 获取map中所有key的个数 // map的遍历 map.set(1,'a').set(2,'b').set(3,'c'); // 遍历全部的键 for(let key of map.keys()){ console.log(key);//1,2,3 } // 遍历全部的值 for(let values of map.values()){ console.log(values);//a,b,c } // 遍历全部的键和值 for(let [key,value] of map.entries()){ console.log(key,value);//1=\u003ea,2=\u003eb,3=\u003ec } // 遍历全部的键和值 map.forEach(function(value,key){ // 注意这里的forEach是value在前，key在后 console.log(key,value); }) 基本用法 Map构造函数参数：必须已经部署iterator接口的数据结构； 此时构造函数参数中的每一个参数必须拥有双元的数组结构； 两种声明方式 let map = new Map([['name', 'zhansan'], ['sex', 'male']]); let items = [['name', 'zhansan'], ['sex', 'male']], map = new Map(); items.forEach(function([key, value]){ map.set(key, value); }); Map遍历的方法 const map = new Map([['name','zhangsan'],['sex','male'],['age',20]]); console.log(map.keys()); console.log(map.values()); console.log(map.entries()); Map.prototype.set() set()方法为Map对象添加或者更新一个指定键（key）和值（value）的新键值对； var myMap = new Map(); // 添加元素 myMap.set(\"bar\", \"foo\"); myMap.set(1, \"foobar\"); console.log(myMap); // 更新元素 myMap.set(\"bar\", 'goo'); console.log(myMap); Map.set()设置属性时，属性名相同时，后面覆盖前面的键值； Map键名覆盖的问题： 本质上与全等的运算方式类型，只是对待NaN问题上不同 const map = new Map(); map.set(-0, 123); console.log(map.get(+0)); // 123 map.set(true,1); map.set('true',2); console.log(map.get(true)); // 1 map.set(NaN,123); map.set(NaN,456); console.log(map.get(NaN)); // 456 Map.prototype.get()方法 get()方法返回某一个Map对象中的一个指定元素； 如果找不到相关的键名，则返回undefined； 注意不同的引用值数据类型作为键名，获取的数据不同； // 引用地址不同的情况; const map = new Map(); map.set([5], 555); map.get([5]); // undefined map.set({}, 555); console.log(map.get({})); // undefined // 引用地址相同的情况 var obj = {id:1}; const map = new Map(); map.set(obj, 'foo'); console.log(map.get(obj)); // 'foo' 应用场景 map转化为数组 const map=new Map([ [1,'one'], [2,'two'], [3,'three'] ]); // 以数组的形式 输出所有key console.log([...map.keys()]); // [1,2,3] // 以数组的形式 输出所有values console.log([...map.values()]); // one,two,three // 以二维数组的形式 输出所有键值对 console.log([...map]); // [1,one],[2,two],[3,three] // 以二维数组的形式 输出所有键值对 console.log([...map.entries()]);// [1,one],[2,two],[3,three] Map 转化为对象 // 声明map对象 const map=new Map().set('yes',true).set('no',false); // 处理方法 function strMapObj(strMap){ // 创建一个新对象 let obj=Object.create(null); // 遍历循环strMap对象 for(let [key,value] of strMap){ obj[key]=value; } // 返回生成的对象 return obj; } console.log(strMapObj(map));//{yes:true,no:false} 对象转化为map // 声明map对象 const map=new Map().set('yes',true).set('no',false); // 处理方法 function objToMap(obj){ let map=new Map(); // Object.keys() 返回 for(let key of Object.keys(obj)){ map.set(key,obj[key]); } return map; } console.log(strMapObj(map)); // yes=\u003etrue,no=\u003efalse ","date":"2023-03-06","objectID":"/vue%E7%AC%94%E8%AE%B0/:24:0","tags":["vue"],"title":"vue基础","uri":"/vue%E7%AC%94%E8%AE%B0/"},{"categories":["vue"],"content":"总结 和Set 对比 Map.prototype上的clear()、has()、size、delete()方法与Set.prototype上相同；唯一不同的是，Set是不存在键名的，键值与键名相同，所以没有get和set的方法，只有add方法；而Map具有键名和键值，所以对应set和get方法； ","date":"2023-03-06","objectID":"/vue%E7%AC%94%E8%AE%B0/:25:0","tags":["vue"],"title":"vue基础","uri":"/vue%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"title: ‘vue基础’ subtitle: ’' date: 2023-03-09T13:58:36+08:00 draft: false tags: [slot][组件] categories: [vue] hiddenFromHomePage: false hiddenFromSearch: false featuredImage: ’' featuredImagePreview: '' ","date":"0001-01-01","objectID":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/:0:0","tags":null,"title":"","uri":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/"},{"categories":null,"content":"license: ‘CC BY-NC 4.0’ 一、插槽Slot的基本使用（测试数据的作用域） ","date":"0001-01-01","objectID":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/:1:0","tags":null,"title":"","uri":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/"},{"categories":null,"content":"1.基本使用：组件的内容全部替换到插槽中 ","date":"0001-01-01","objectID":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/:2:0","tags":null,"title":"","uri":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/"},{"categories":null,"content":"2.数据的作用域：父组件的数据也可以显示到子组件中 二、具名插槽Slot的基本使用： ","date":"0001-01-01","objectID":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/:3:0","tags":null,"title":"","uri":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/"},{"categories":null,"content":"1.基本使用： 子组件：\u003cslot name=\"left\"\u003e\u003c/slot\u003e 父组件：\u003ctemplate v-slot:left\u003e \u003cbutton\u003e左边的按钮\u003c/button\u003e \u003c/template\u003e， 可以简写：\u003ctemplate #left\u003e \u003cbutton\u003e左边的按钮\u003c/button\u003e \u003c/template\u003e ","date":"0001-01-01","objectID":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/:4:0","tags":null,"title":"","uri":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/"},{"categories":null,"content":"2.默认插槽名： 一个不带 name 的slot，会带有隐含的名字 default ","date":"0001-01-01","objectID":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/:5:0","tags":null,"title":"","uri":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/"},{"categories":null,"content":"3.动态插槽名： 目前我们使用的插槽名称都是固定的，比如 v-slot:left等等，我们可以通过 v-slot:[dynamicSlotName]方式动态绑定一个名称 三、渲染作用域（作用域插槽的背景） ","date":"0001-01-01","objectID":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/:6:0","tags":null,"title":"","uri":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/"},{"categories":null,"content":"1.渲染作用域： 父级模板里的所有内容都是在父级作用域中编译的 子模板里的所有内容都是在子作用域中编译的 四、作用域插槽（父组件没法直接用子组件的数据，有渲染作用域） ","date":"0001-01-01","objectID":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/:7:0","tags":null,"title":"","uri":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/"},{"categories":null,"content":"1.作用： 父组件可以访问子组件的数据，并按照父组件期望的形式进行数据展示（子组件定义插槽） ","date":"0001-01-01","objectID":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/:8:0","tags":null,"title":"","uri":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/"},{"categories":null,"content":"2.简单理解： 作用域插槽就是子组件用$emit向父组件传递数据的另一种表现 父组件访问子组件的数据： 父组件获取组件slot属性：v-slot=\"slotProps\"， 子组件将数据绑定到动态属性中：\u003cslot :item=\"item\"\u003e\u003c/slot\u003e 按照父组件期望的形式进行数据展示： 子组件中定义slot插槽：\u003cslot :item=\"item\" :index=\"index\"\u003e\u003c/slot\u003e 父组件通过插槽的方式替换子组件的插槽内容 五、动态组件 ","date":"0001-01-01","objectID":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/:9:0","tags":null,"title":"","uri":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/"},{"categories":null,"content":"1.概念 动态组件是使用 component 组件，通过一个特殊的attribute is 来实现 ","date":"0001-01-01","objectID":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/:10:0","tags":null,"title":"","uri":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/"},{"categories":null,"content":"2.基本用法： ","date":"0001-01-01","objectID":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/:11:0","tags":null,"title":"","uri":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/"},{"categories":null,"content":"3.is绑定的值是什么内容？ 可以是通过component函数注册的组件 在一个组件对象的components对象中注册的组件（局部组件） 六、动态组件传参 ","date":"0001-01-01","objectID":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/:12:0","tags":null,"title":"","uri":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/"},{"categories":null,"content":"1.动态组件传参跟普通组件一样 区别：当前动态组件的 is 绑定哪个组件，参数就在哪个组件上 七、webpack代码（组件）分包 ","date":"0001-01-01","objectID":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/:13:0","tags":null,"title":"","uri":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/"},{"categories":null,"content":"1.默认的打包过程 默认情况下，在构建整个组件树的过程中，因为组件和组件之间是通过模块化直接依赖的，那么webpack在打包时就会将组 件模块打包到一起（比如一个app.js文件中） 这个时候随着项目的不断庞大，app.js文件的内容过大，会造成首屏的渲染速度变慢 ","date":"0001-01-01","objectID":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/:14:0","tags":null,"title":"","uri":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/"},{"categories":null,"content":"2.代码的分包 所以，对于一些不需要立即使用的组件，我们可以单独对它们进行拆分，拆分成一些小的代码块chunk.js 这些chunk.js会在需要时从服务器加载下来，并且运行代码，显示对应的内容 八、异步组件：Vue的代码分包（实际开发用的不多，用路由懒加载比较多） ","date":"0001-01-01","objectID":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/:15:0","tags":null,"title":"","uri":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/"},{"categories":null,"content":"1.背景 如果我们的项目过大了，对于某些组件我们希望通过异步的方式来进行加载（目的是可以对其进行分包处理），那 么Vue中给我们提供了一个函数：defineAsyncComponent。 ","date":"0001-01-01","objectID":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/:16:0","tags":null,"title":"","uri":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/"},{"categories":null,"content":"2.defineAsyncComponent接受两种类型的参数： 类型一：工厂函数，该工厂函数需要返回一个Promise对象； 类型二：接受一个对象类型，对异步函数进行配置； 九、异步组件和Suspense： ","date":"0001-01-01","objectID":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/:17:0","tags":null,"title":"","uri":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/"},{"categories":null,"content":"1.注意： 目前Suspense显示的是一个实验性的特性，API随时可能会修改。 ","date":"0001-01-01","objectID":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/:18:0","tags":null,"title":"","uri":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/"},{"categories":null,"content":"2.Suspense是一个内置的全局组件，该组件有两个插槽： default：如果default可以显示，那么显示default的内容； fallback：如果default无法显示，那么会显示fallback插槽的内容； 十、组件的ref和$refs ","date":"0001-01-01","objectID":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/:19:0","tags":null,"title":"","uri":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/"},{"categories":null,"content":"1.使用场景： 某些情况下，我们在组件中想要直接获取到元素对象或者子组件实例，这个时候，我们可以给元素或者组件绑定一个ref的attribute属性 组件实例有一个$refs属性，它一个对象Object，持有注册过 ref attribute 的所有 DOM 元素和组件实例。 十一、组件的v-model ","date":"0001-01-01","objectID":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/:20:0","tags":null,"title":"","uri":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/"},{"categories":null,"content":"1.原生input标签的v-model v-model默认帮助我们完成了两件事：v-bind:value的数据绑定和@input的事件监听 ","date":"0001-01-01","objectID":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/:21:0","tags":null,"title":"","uri":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/"},{"categories":null,"content":"2.组件的v-model v-model默认帮助我们完成了两件事：v-bind:modelValue的数据绑定和@update:model-value的事件监听 ","date":"0001-01-01","objectID":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/:22:0","tags":null,"title":"","uri":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/"},{"categories":null,"content":"3.代码案例 \u003chy-input v-model=\"message\"\u003e\u003c/hy-input\u003e \u003chy-input :modelValue=\"message\" @update:model-value=\"message = $event\"\u003e\u003c/hy-input\u003e ","date":"0001-01-01","objectID":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/:23:0","tags":null,"title":"","uri":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/"},{"categories":null,"content":"4.子组件input标签中:vlaue和@input简写方式 ","date":"0001-01-01","objectID":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/:24:0","tags":null,"title":"","uri":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/"},{"categories":null,"content":"5.组件中绑定两个v-model ","date":"0001-01-01","objectID":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/:25:0","tags":null,"title":"","uri":"/%E6%8F%92%E6%A7%BD%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/"}]